"""
train_model.py
--------------
Script to train a text classification model on expense descriptions.

Workflow:
1. Load training PKLs generated by features.py
2. Train Logistic Regression
3. If test CSV provided:
     - Transform test data using training vectorizer
     - Evaluate model on test set
   Else:
     - Split training features internally (train_test_split)
4. Print evaluation metrics
5. Save trained model
"""

import os
import time
import argparse
from typing import Tuple, List

import pandas as pd
import joblib
from sklearn.linear_model import LogisticRegression
from sklearn.metrics import accuracy_score, precision_recall_fscore_support, classification_report
from sklearn.model_selection import train_test_split
from features import load_data, extract_features  # reuse features.py functions


def transform_test_data(test_file: str, vectorizer) -> Tuple:
    """
    Convert test CSV descriptions into TF-IDF features using training vectorizer.

    Args:
        test_file (str): Path to test CSV
        vectorizer: TF-IDF vectorizer trained on training data

    Returns:
        Tuple: (X_test_features, y_test_labels)
    """
    df_test = load_data(test_file)
    X_test = vectorizer.transform(df_test["description"])
    y_test = df_test["category"]
    return X_test, y_test


def train_model(X_train, y_train) -> LogisticRegression:
    """
    Train Logistic Regression on given features.

    Args:
        X_train: Feature matrix
        y_train: Labels

    Returns:
        LogisticRegression: trained model
    """
    model = LogisticRegression(max_iter=500)
    model.fit(X_train, y_train)
    return model


def evaluate_model(model, X_test, y_test):
    """
    Evaluate model and print metrics.

    Args:
        model: trained model
        X_test: test features
        y_test: true labels
    """
    y_pred = model.predict(X_test)
    accuracy = accuracy_score(y_test, y_pred)
    precision, recall, f1, _ = precision_recall_fscore_support(y_test, y_pred, average="weighted")

    print("\nðŸ“Š Evaluation Metrics:")
    print(f"   Accuracy : {accuracy:.2f}")
    print(f"   Precision: {precision:.2f}")
    print(f"   Recall   : {recall:.2f}")
    print(f"   F1 Score : {f1:.2f}\n")

    print("ðŸ“‘ Classification Report:")
    print(classification_report(y_test, y_pred))


def main():
    start_time = time.time()

    parser = argparse.ArgumentParser(description="Train expense categorization model.")
    parser.add_argument("--train", required=True, help="Path to training CSV (features.py will generate PKLs)")
    parser.add_argument("--test", help="Optional path to test CSV")
    args = parser.parse_args()

    # Step 1: Generate/load training features
    print(f"ðŸ“‚ Generating/loading features for training data: {args.train}")
    os.makedirs("models", exist_ok=True)

    # Generate features PKLs if not already exist
    X_pkl_path = "models/X_features.pkl"
    y_pkl_path = "models/y_labels.pkl"
    vectorizer_path = "models/tfidf_vectorizer.pkl"

    if not os.path.exists(X_pkl_path) or not os.path.exists(y_pkl_path) or not os.path.exists(vectorizer_path):
        from features import main as features_main
        import sys
        sys.argv = ["features.py", "--data", args.train]  # call features.py programmatically
        features_main()

    X_train = joblib.load(X_pkl_path)
    y_train = joblib.load(y_pkl_path)
    vectorizer = joblib.load(vectorizer_path)

    # Step 2: Prepare test data
    if args.test:
        print(f"ðŸ“‚ Transforming test CSV: {args.test}")
        X_test, y_test = transform_test_data(args.test, vectorizer)
    else:
        print("ðŸ“‚ No test CSV provided, performing internal train_test_split (80/20)")
        X_train, X_test, y_train, y_test = train_test_split(
            X_train, y_train, test_size=0.2, random_state=42, stratify=y_train
        )

    # Step 3: Train model
    print("âœ¨ Training Logistic Regression model...")
    model = train_model(X_train, y_train)

    # Step 4: Evaluate
    evaluate_model(model, X_test, y_test)

    # Step 5: Save model
    model_path = "models/expense_model.pkl"
    joblib.dump(model, model_path)
    print(f"\nðŸ’¾ Model saved to {model_path}")

    elapsed = time.time() - start_time
    print(f"\nâœ… Training complete! Total execution time: {elapsed:.2f} seconds")


if __name__ == "__main__":
    main()

